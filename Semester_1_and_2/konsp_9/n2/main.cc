#include <iostream>
#include <unistd.h>
#include <sys/wait.h>

int main() {
	std::clog << "Docherny proces ";
	pid_t pid = fork(); 

	if (pid == 0) { // pid = 0 если находимся в дочернем процессе
		const char* name = "expr";
		execlp(name, name, "2", "+", "2", "*", "2", nullptr); // можно в конце напис. 0 
		exit(0);// экзит нужен т.к. вслучае ошибки exec она вернётся и её нужно будет завершить принудительно
	}

	int *status = nullptr;
	pid_t id =  wait(status);
	std::clog << "konec procesa id: " << id;

	return 0;
	
}	
//fork - функция обёртка, копирующая процессы(память) и возвращающая Первый раз  дочерний процесс, и в данном случае возвращаемое значение равно нулю. Второй раз — в родительский процесс, и в данном случае возвращаемое значение равно номеру дочернего процесса. По соглашениию 
// первый аргумент exec(name...) является именем программы	

//execlp Эта функция заменяет текущий бинарный код, загруженный в память, на код из указанного файла. Суффикс p означает, что система должна сама найти исполняемый файл с указанным именем в стандартных директориях. После загрузки в память все потоки останавливаются и запускается функция main из только что загруженной программы. В конце списка exec должен быть nullptr или 0  т.к размер не передаётся  и мы показваем конец
	
	
	//Этот код создает дочерний процесс с помощью вызова fork(). В дочернем процессе происходит замещение текущего образа процесса на образ исполняемого файла "expr" с помощью вызова execlp(). Этот исполняемый файл вычисляет результат арифметического выражения "2 + 2 * 2". После выполнения дочернего процесса, родительский процесс вызывает функцию wait(), чтобы дождаться завершения дочернего процесса. Родительский процесс выводит идентификатор завершенного процесса в поток ошибок.
